= Днес

* Мета данни
* Minesweeper
* Коментари по решението

= Трета задача

* Ще ви я пуснем до края на деня
* Проверете на обичайното място
* Ще има и тема във форумите
* Очаквайте и ново предизвикателство

= Въпроси за Snickers

* Какво прави `lazy-seq`?
* Как работи `nREPL`?

= Мета данни

* Отгоре, отгоре (ще говорим още за тях)
* Данни за данните
* Можем да ги добавяме на всички структури от данни
* Вървят заедно със структурата от данни
* Запазват се след операции върху оригиналната структура
* Едно от супер яките неща в Clojure

= Мета данни (2)

:annotate

  ^{:meta "data"} [] ; =>

  (def v ^{:holds "numbers", :range "1..5"} [1 2 3 4 5])
  (meta v) ; =>

* `^{}` слага мета данни на структурата след себе си
* `meta` ни връща мета данните на структура

= Мета данни (3)

:annotate
  (with-meta [] {:owner "John"})        ; =>
  (meta (with-meta [] {:owner "John"})) ; =>


  (def owned (with-meta ^{:type "thing"} [] {:owner "Peter"}))
  (meta owned)                          ; =>


  (def owned (vary-meta ^{:type "thing"} [] assoc :owner "Peter"))
  (meta owned)                          ; =>

  (vary-meta ^{:type "thing"} [] assoc :owner "Peter")
  (vary-meta ^{:type "thing"} [] #(assoc % :owner "Peter"))

* `with-meta` връща нова структура с нови мета данни
* `vary-meta` връща нова структура с променени мета данни

= Minesweeper
== Demo

Кодът е в github: [gh:fmi/clojure-examples]

= Какво следва?

+ Ще разгледаме някои интересни неща около решението
+ Ще говорим генерално за подхода при решаване на проблеми с Clojure

= Immutability
== отново и отново

* Решихме си проблема без да мутираме нищо
* Логиката ни е само pure функции, които вземат нещо и връщат ново нещо
* Елиминирахме грешките идващи от това, че нещата могат да се променят
* Мислим само за входа и изхода на функциите, което прави кода по-лесен за разбиране
* Външни фактори не могат да прецакат, работещия ни код
* Можем спокойно да преизползваме тази функционалност в други системи
* Тестването става тривиално
* Най-вече печелим простота

= Данни

<blockquote>Data all the things.</blockquote>

* Изкарахме данните от класовете и абстракциите
* Логиката на приложението и данните, с които то работи са две отделни неща
* Всички данни са на едно място
* Възползваме се максимално от мощните инструменти за работа с данни в Clojure

= Изпълнение на програмата

* Поток от трансформации
* Трансформираме началните данни в желаните резултатни данни
* Всички трансформации са immutable
* Лесно можем да ги пуснем на отделни ядра или отделни системи

= Владеем времето

* Имаме точно едно определено състояние във всеки един момент от време
* Можем да записваме история и това е евтино с persistent структурите
* Можем да пътуваме в миналото и да скочим във всеки един момент
* Можем да пътуваме в бъдещето
* Можем да възпроизведем всеки един сценарий и резултат
* Особено ни интересуват сценариите, когато възниква бъг
* И получаваме това по подразбиране с нула инцидентна сложност

= Но нещата се променят

* Неизбежно ако искаме да направим нещо полезно
* Ограничаваме страничните ефекти до минимум
* Ако е възможно най-добре да са на едно място
* Това е обикновено след трансформациите ни или преди тях

= Големи системи

<blockquote>Designing is fundamentally about taking things apart.</blockquote>
<p style="padding-left: 400px;">Rich Hickey</p>

* Имаме композиция на данни и функции
* Данните се споделят лесно между различни системи, особено когато са immutable
* Нямаме типове и интерфейси, които щяха доста да затруднят споделянето
* Целта е ядро от автономни immutable подсистеми, които не споделят променящо се състояние

= И последно

* В есенцията си това е подхода за решаване на проблеми с Clojure
* Прилагаме го за доста [интересни](https://github.com/swannodette/om) [неща](http://www.datomic.com/)
* Още по темата във [видеата на Rich Hickey](http://www.infoq.com/author/Rich-Hickey)
