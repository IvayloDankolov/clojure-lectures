= Разширяване на синтаксиса на езика

* Искаме да си спестим писане
* Искаме нашите собствени конструкции да са максимално подобни на тези в езика
* Искаме да си направим DSL (Domain Specific Language) и за тази цел трябва леко да огънем синтаксиса на езика

= Пример от C

* В C имаме препроцесор, който може да променя изходния код на програмата преди да се е компилирала.
* Работи с програмата като текстов низ и може да заместваме в нея или да режем/добавяме парчета код
* `include`, `if`, `ifdef`, `define `
* Доста дървено и чупливо

= unless в C
== Оригинал

{{{
<pre>
#define unless(x)   if(!(x))

int main() {
  if (1)
    unless(1) return 1;
  else
    return 2;
  return 0;
}
</pre>
}}}

* Какъв ще е резултата от програмата?
* 0?


= unless в C
== Заместено

{{{
<pre>
#define unless(x)   if(!(x))

int main() {
  if (1)
    if(!(1)) return 1;
  else
    return 2;
  return 0;
}
</pre>
}}}


= unless в C
== Индентирано

{{{
<pre>
#define unless(x)   if(!(x))

int main() {
  if (1)
    if(!(1))
      return 1;
    else
      return 2;
  return 0;
}
</pre>
}}}

= В Clojure е различно

* Няма нужда да се занимаваме с низове – кодът се изразява със структурите от данние на езика
* Можем да си напишем функции, които не се различават синтактично от изразните средства на Clojure
* Изключенията са много малко (reader macros)
* Въпрос: Значи можем да си свършим всичко с функции?

= unless в Clojure
== постановка
:code
  (defn check-access [name]
    (unless (#{"Clark" "Bruce"} name)
      (println "You're not allowed!")))

= unless в Clojure
== функция
:code
  (defn unless [test then]
   (if (not test)
    then))

  (check-access "Baba")
  ; You're not allowed!

  (check-access "Bruce")
  ; You're not allowed!

= unless в Clojure
== функция

* Тази функция `unless` не ни върши работа.
* Когато Clojure вика `unless` оценява всички аргументи, включително `println`-а.
* Възможно решение: `(unless … #(println "You're not allowed"))`, но е грозно.

= Макроси

* Работят по време на компилация
* Получават кодът като структура от данни
* Връщат кодът за изпълнение като структура от данни
* Решават какво и как да изпълнят
